import simpleGit from "simple-git";
import path from "path";
import fs from "fs-extra";
import { getIPPOCAdapter } from "../ippoc-adapter";

export class GitEvolution {
  private git;
  private adapter;

  constructor(repoPath: string) {
    this.git = simpleGit(repoPath);
    this.adapter = getIPPOCAdapter();
    console.log("[Evolution] Git agent active.");
  }

  /**
   * Propose and test a code patch
   */
  /**
   * Propose and test a code patch using Internal Evolution Tracking.
   * Steps:
   * 1. Check/Create 'evolution/stable' branch (disjoint from main).
   * 2. Create 'evolution/mutation-X' branch.
   * 3. Simulate.
   * 4. If PASS: Merge to 'evolution/stable' and tag with git-notes.
   */
  public async proposePatch(featureName: string, code: string): Promise<boolean> {
    const mutationId = `mutation-${Date.now()}`;
    const mutationBranch = `evolution/${featureName}-${mutationId}`;
    const stableBranch = "evolution/stable";
    
    console.log(`[Evolution] Proposing internal mutation: ${mutationBranch}`);
    
    try {
      // 1. Ensure evolution/stable exists
      const branches = await this.git.branchLocal();
      if (!branches.all.includes(stableBranch)) {
          console.log("[Evolution] Initializing evolution/stable branch...");
          // We branch off current HEAD but will track separately
          await this.git.checkoutLocalBranch(stableBranch);
      } else {
          await this.git.checkout(stableBranch);
      }

      // 2. Create Mutation Branch
      await this.git.checkoutLocalBranch(mutationBranch);
      
      // 3. Write Code to a temporary file for simulation
      const tempFile = path.join(process.cwd(), `temp-patch-${Date.now()}.rs`);
      await fs.writeFile(tempFile, code);
      console.log("[Evolution] Writing patch...");

      // 4. Run WorldModel simulation
      const simulationPassed = await this.adapter.simulateCode(code, "full_execution");

      if (simulationPassed) {
         console.log("[Evolution] Simulation passed. Committing to internal history...");
         await this.git.add(".");
         await this.git.commit(`mutation: ${featureName}`);
         
         // 5. Add Metadata via Git Notes (Internal Evaluation Tracking)
         // equivalent to: git notes add -m "Score: 1.0"
         await this.git.raw(["notes", "add", "-m", `{"score": 1.0, "type": "mutation", "id": "${mutationId}"}`]);
         
         console.log("[Evolution] Merging to evolution/stable...");
         await this.git.checkout(stableBranch);
         await this.git.merge([mutationBranch]);
         
         // Cleanup
         await fs.remove(tempFile);
         return true;
      } else {
         console.warn("[Evolution] Simulation FAILED. Dropping mutation.");
         await this.git.checkout(stableBranch); // Return to stable
         await this.git.deleteLocalBranch(mutationBranch, true);
         
         // Cleanup
         await fs.remove(tempFile);
         return false;
      }
    } catch (error) {
       console.error("[Evolution] Failed:", error);
       // Attempt crash recovery
       try { await this.git.checkout("master"); } catch {} 
       return false;
    }
  }

  /**
   * Check for recent failures and propose fixes
   */
  public async proposeFixes(): Promise<number> {
    console.log("[Evolution] Analyzing recent failures...");
    
    // Heuristic: Scan a hypothetical 'error.log' for stack traces or 'Error:' patterns
    // In a real system, this would query a structured Logger or Observability platform
    const logFile = path.join(process.cwd(), "error.log");
    if (!await fs.pathExists(logFile)) {
        console.log("[Evolution] No error.log found, skimming.");
        return 0;
    }

    const content = await fs.readFile(logFile, "utf-8");
    const errors = content.split("\n").filter(l => l.includes("Error:") || l.includes("Exception"));

    if (errors.length > 0) {
        console.log(`[Evolution] Found ${errors.length} errors. Proposing general fix...`);
        // Simulate generating a fix for the most recent error
        const recentError = errors[errors.length - 1];
        const fixCode = `// Vulnerability Fix for: ${recentError}\n// Auto-generated by IPPOC Evolution\nfn apply_fix() {\n    println!("Fixed vulnerability pattern: ${recentError}");\n}`;
        
        await this.proposePatch("auto-fix-001", fixCode);
        return 1;
    }

    return 0;
  }

  /**
   * Check for possible optimizations
   */
  public async proposeOptimizations(): Promise<number> {
    console.log("[Evolution] Analyzing for optimizations...");
    
    // Heuristic: Check for large files that should be ignored or optimized
    try {
        const files = await fs.readdir(process.cwd());
        let optimizationsFound = 0;
        
        for (const file of files) {
            const stat = await fs.stat(file);
            if (stat.isFile() && stat.size > 1024 * 1024) { // > 1MB
                console.log(`[Evolution] Optimization: File ${file} is large (${stat.size} bytes). Consider compressing or adding to .gitignore.`);
                await this.proposePatch(`optimize-${file}`, `// Optimization Proposal: Move ${file} to LFS or compress.\n`);
                optimizationsFound++;
            }
        }
        return optimizationsFound;
    } catch (e) {
        return 0;
    }
  }

  /**
   * Update repository from remote
   */
  public async updateFromRemote(): Promise<boolean> {
    try {
      console.log("[Evolution] Updating from remote...");
      await this.git.pull();
      return true;
    } catch (error) {
      console.error("[Evolution] Update failed:", error);
      return false;
    }
  }
}
